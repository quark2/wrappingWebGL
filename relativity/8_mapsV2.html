<html>
<head>
<script type="text/javascript" src="../src/glMatrix-0.9.5.min.js"></script>

<script type="text/javascript" src = "../src/gl_wrapper.js"></script>

<script id = "fscodeRelativity" type = "x-shader/x-fragment">
precision mediump float;

uniform bool u_bTexture;

uniform sampler2D u_Sampler;
uniform sampler2D u_SamplerThermal;

// The following uniform variables are added for Lorentz transformation
uniform float u_fVelFrag;
uniform float u_fGammaFrag;

uniform bool u_bIsOnDopplerEff;
uniform bool u_bIsThermalObj;

uniform vec2 u_vec2TexOffset;
uniform vec2 u_vec2TexArea;

varying vec3 vecLight;

varying vec4 vecColor;
varying vec2 vecTextureCoord;

// The following varying variables are added for Lorentz transformation
varying vec3 vecPosOrg;


/*
   The following two functions for HSL-to-RGB are from 
   
   http://www.rapidtables.com/convert/color/rgb-to-hsl.htm
*/
vec3 myRGBtoHSL(vec3 clrRGB) {
    vec3 clrHSL; // x : H, y : S, z : L
    
    float fMin, fMax;
    float fDelta;
    
    fMin = fMax = clrRGB.r;
    
    if ( fMin > clrRGB.g ) {
        fMin = clrRGB.g;
    }
    
    if ( fMin > clrRGB.b ) {
        fMin = clrRGB.b;
    }
    
    if ( fMax < clrRGB.g ) {
        fMax = clrRGB.g;
    }
    
    if ( fMax < clrRGB.b ) {
        fMax = clrRGB.b;
    }
    
    fDelta = fMax - fMin;
    clrHSL.z = 0.5 * ( fMax + fMin );
    
    if ( fDelta == 0.0 ) {
        clrHSL.x = 0.0;
        clrHSL.y = 0.0;
    } else {
        if ( fMax == clrRGB.r ) {
            clrHSL.x = 60.0 * ( ( clrRGB.g - clrRGB.b ) / fDelta + 0.0 );
            
            if ( clrHSL.x < -0.00001 ) {
                clrHSL.x += 360.0;
            }
        } else if ( fMax == clrRGB.g ) {
            clrHSL.x = 60.0 * ( ( clrRGB.b - clrRGB.r ) / fDelta + 2.0 );
        } else if ( fMax == clrRGB.b ) {
            clrHSL.x = 60.0 * ( ( clrRGB.r - clrRGB.g ) / fDelta + 4.0 );
        }
        
        clrHSL.y = fDelta / ( 1.0 - abs( 2.0 * clrHSL.z - 1.0 ) );
    }
    
    return clrHSL;
}


/*
   The following two functions for HSL-to-RGB are from 
   
   http://stackoverflow.com/questions/180/function-for-creating-color-wheels
*/
float myToRGB1(float fRm1, float fRm2, float fHue) {
    if      ( fHue > 360.0 ) fHue -= 360.0;
    else if ( fHue <   0.0 ) fHue += 360.0;
    
    if      ( fHue <  60.0 ) fRm1 = fRm1 + ( fRm2 - fRm1 ) * fHue / 60.0;
    else if ( fHue < 180.0 ) fRm1 = fRm2;
    else if ( fHue < 240.0 ) fRm1 = fRm1 + ( fRm2 - fRm1 ) * ( 240.0 - fHue ) / 60.0;
    
    return fRm1;
}


vec3 myHSLtoRGB(vec3 clrHSL) {
    vec3 clrRGB;
    
    float fSaturation, fLuminance, fHue;
    float fRm1, fRm2;
    
    fHue = clrHSL[ 0 ];
    fSaturation = clrHSL[ 1 ];
    fLuminance = clrHSL[ 2 ];
    
    if ( fSaturation == 0.0 ) {
        clrRGB[ 0 ] = clrRGB[ 1 ] = clrRGB[ 2 ] = fLuminance;
    } else {
        if ( fLuminance <= 0.5 ) {
            fRm2 = fLuminance + fLuminance * fSaturation;
        } else {
            fRm2 = fLuminance + fSaturation - fLuminance * fSaturation;
        }
        
        fRm1 = 2.0 * fLuminance - fRm2;
        
        clrRGB[ 0 ] = myToRGB1(fRm1, fRm2, fHue + 120.0);
        clrRGB[ 1 ] = myToRGB1(fRm1, fRm2, fHue);
        clrRGB[ 2 ] = myToRGB1(fRm1, fRm2, fHue - 120.0);
    }
    
    return clrRGB;
}


vec3 myApplyDopplerEffToSimpleReflection(vec3 clrHSL, vec3 vecPos) {
    vec3 vecDir;
    float fShiftPar;
    
    float fWavelength;
    
    // Calculating the factor from Doppler effect
    // Note that the light 'comes' to the camera, the negative sign is needed
    vecDir = normalize(vecPos);
    fShiftPar = u_fGammaFrag * 1.0 + u_fGammaFrag * u_fVelFrag * ( -vecDir[ 2 ] );
    
    // Do not forget wavelength = c / frequency
    fWavelength = 650.0 - clrHSL[ 0 ] / 270.0 * ( 650.0 - 475.0 );
    fWavelength /= fShiftPar;
    clrHSL[ 0 ] = ( 650.0 - fWavelength ) * 270.0 / ( 650.0 - 475.0 );
    
    // There is cutoff -- infrared and ultraviolet.
    
    if ( -5.0 <= clrHSL[ 0 ] && clrHSL[ 0 ] <= 0.0 ) {
        clrHSL[ 2 ] *= ( clrHSL[ 0 ] + 5.0 ) / 5.0;
        clrHSL[ 0 ] = 0.0;
    } else if ( 270.0 <= clrHSL[ 0 ] && clrHSL[ 0 ] <= 275.0 ) {
        clrHSL[ 2 ] *= ( 275.0 - clrHSL[ 0 ] ) / 5.0;
        clrHSL[ 0 ] = 270.0;
    } else if ( -5.0 > clrHSL[ 0 ] || clrHSL[ 0 ] > 275.0 ) {
        clrHSL[ 0 ] = 0.0;
        clrHSL[ 1 ] = 0.0;
        clrHSL[ 2 ] = 0.0;
    }
    
    return clrHSL;
}


vec3 myCalcColorOfThermalObj(vec2 texCoord, vec3 vecPos) {
    vec3 clrThermalFluc;
    vec3 clrRGB;
    
    float fTemperMax = 10240.0;
    
    float fTemperMain = 4000.0;
    float fTemperFluc = 500.0;
    
    float fWeight = 4.0;
    
    vec3 vecDir;
    float fShiftPar;
    
    vec2 vec2PosColor, vec2PosOrder;
    
    // Calculating the factor from Doppler effect
    // Note that the light 'comes' to the camera, the negative sign is needed
    vecDir = normalize(vecPos);
    fShiftPar = u_fGammaFrag * 1.0 + u_fGammaFrag * u_fVelFrag * ( -vecDir[ 2 ] );
    
    clrThermalFluc = texture2D(u_Sampler, texCoord).rgb;
    
    vec2PosColor.s = ( fTemperMain + fTemperFluc * ( clrThermalFluc.r - 0.5 ) ) * fShiftPar / fTemperMax;
    vec2PosColor.t = 0.5;
    
    if ( vec2PosColor.s > 0.9 ) { // To avoid the topology (1.0 = 0.0)
        // The below is from the Stefan-Bolzmann law ; 0.6561 = 0.9^4
        fWeight *= vec2PosColor.s * vec2PosColor.s * vec2PosColor.s * vec2PosColor.s / 0.6561;
        vec2PosColor.s = 0.9;
    }
    
    clrRGB = fWeight * texture2D(u_SamplerThermal, vec2PosColor).rgb;
    
    return clrRGB;
}


void main(void) {
    vec4 vec4MainClr;
    vec3 vecHSL;
    vec3 vecRGB;
    
    vec2 vecTexCoordActual;
    
    vec4MainClr = vecColor;
    
    vecTexCoordActual.s = u_vec2TexOffset.s + u_vec2TexArea.s * vecTextureCoord.s;
    vecTexCoordActual.t = u_vec2TexOffset.t + u_vec2TexArea.t * vecTextureCoord.t;
    
    if ( !u_bIsThermalObj ) {
        // To treat the frequency we need to represent the color in HSL system
        vecHSL = ( u_bTexture ? myRGBtoHSL(texture2D(u_Sampler, vecTexCoordActual).rgb) : 
            vec4MainClr.rgb );
        
        if ( u_bIsOnDopplerEff ) {
            vecHSL = myApplyDopplerEffToSimpleReflection(vecHSL, vecPosOrg);
        }
        
        vecRGB = myHSLtoRGB(vecHSL) * vecLight;
    } else {
        vecRGB = myCalcColorOfThermalObj(vecTexCoordActual, vecPosOrg);
        vec4MainClr.a = 1.0;
    }
    
    // Now our job is almost done while going back to the RGB is remaining
    vec4MainClr.rgb = vecRGB;
    
    gl_FragColor = vec4(vec4MainClr.rgb, vec4MainClr.a);
}
</script>

<script id = "vscodeRelativity" type = "x-shader/x-vertex">
attribute vec3 a_vec3VertexPosition;
attribute vec3 a_vec3VertexNormal;
attribute vec4 a_vec4VertexColor;
attribute vec2 a_vec2TextureCoord;

uniform mat4 u_matP;
uniform mat4 u_matMV;
uniform mat3 u_matN;

uniform mat4 u_matMVWorld;
uniform mat3 u_matNWorld;

uniform vec4 u_vecClrUniform;

uniform vec3 u_vecClrAmb;
uniform vec3 u_vecClrDir;
uniform vec3 u_vecDirLight;

uniform bool u_bLight;
uniform bool u_bColored;
uniform bool u_bTexture;

// The following uniform variables are added for Lorentz transformation
uniform vec3  u_vecPosCenter;
uniform float u_fVelVtx;
uniform float u_fGammaVtx;

uniform bool u_bIsStar;
uniform float u_fSizeStarX;
uniform float u_fSizeStarY;

varying vec3 vecLight;

varying vec4 vecColor;
varying vec2 vecTextureCoord;

// The following varying variables are added for Lorentz transformation
varying vec3 vecPosOrg;


// This is the core code for Terrell-Penrose effect
vec3 myTransformPos(vec3 vecPos) {
    vec3 vecRes;
    
    vecRes[ 0 ] = vecPos[ 0 ];
    vecRes[ 1 ] = vecPos[ 1 ];
    vecRes[ 2 ] = u_fGammaVtx * vecPos[ 2 ] - u_fGammaVtx * u_fVelVtx * length(vecPos);
    
    return vecRes;
}


void main(void) {
    vec4 vec4PosWorld;
    vec3 vecPosCalc, vecNorCalc;
    
    if ( !u_bIsStar ) {
        vec4PosWorld = u_matMVWorld * vec4(a_vec3VertexPosition, 1.0);
        
        vecPosCalc = vec4PosWorld.xyz - u_vecPosCenter;
        // The extra factor is to minimize the nonlinear effect of the transformation
        vecNorCalc = 0.05 * u_matNWorld * a_vec3VertexNormal + vecPosCalc;
        
        vecPosOrg = vecPosCalc;
        
        vecPosCalc = myTransformPos(vecPosCalc);
        
        gl_Position = u_matP * u_matMV * vec4(vecPosCalc, 1.0);
        vecNorCalc = normalize(myTransformPos(vecNorCalc) - vecPosCalc);
    } else {
        vec4PosWorld = u_matP * u_matMV * vec4(myTransformPos(a_vec3VertexPosition), 1.0);
        vec4PosWorld /= vec4PosWorld[ 3 ];
        
        if ( vec4PosWorld[ 2 ] < 1.0 ) {
            vec4PosWorld[ 2 ] = 0.9999999;
        }
        
        gl_Position = vec4PosWorld + vec4(u_fSizeStarX * a_vec2TextureCoord[ 0 ], 
            u_fSizeStarY * a_vec2TextureCoord[ 1 ], 0.0, 0.0);
        vecNorCalc = vec3(0.0, 0.0, 0.0); // In this case light is turned off
    }
    
    if ( u_bLight ) {
        vec3 vec3NorTrans = u_matN * vecNorCalc;
        float fWeightDir = max(dot(vec3NorTrans, u_vecDirLight), 0.0);
        vecLight = u_vecClrAmb + u_vecClrDir * fWeightDir;
    } else {
        vecLight = vec3(1.0, 1.0, 1.0);
    }
    
    vecColor = ( u_bColored ? a_vec4VertexColor : u_vecClrUniform );
    vecTextureCoord = a_vec2TextureCoord;
}
</script>

<script id = "fscodePostEff" type = "x-shader/x-fragment">
precision mediump float;

uniform sampler2D u_Sampler;

uniform sampler2D u_Sampler4;

// For configuration : the below line will be replaced by something
int nDrawMode_ExtractExceed = 1;
int nDrawMode_ScaleDown     = 2;
int nDrawMode_Blur          = 3;

uniform int u_nModeDraw;

uniform vec2 u_vecSizePixel;

varying vec2 vecTextureCoord;


float myCalcGaussianWeight(vec2 vecX, float fSigma) {
    return 0.06 * exp(-( vecX.s * vecX.s + vecX.t * vecX.t ) * 0.5 / fSigma / fSigma ) / fSigma;
}


void main(void) {
    const int nSize = 4;
    
    vec3 vecMainClr;
    
    vec2 vec2Delta;
    vec3 clrSample;
    
    vecMainClr = texture2D(u_Sampler, vecTextureCoord).rgb;
    
    if ( u_nModeDraw == nDrawMode_ExtractExceed ) {
        if ( vecMainClr.r < 1.5 ) {vecMainClr.r = 0.0;}
        if ( vecMainClr.g < 1.3 ) {vecMainClr.g = 0.0;}
        if ( vecMainClr.b < 1.1 ) {vecMainClr.b = 0.0;}
    } else if ( u_nModeDraw == nDrawMode_ScaleDown ) {
        // Nothing to do anything
    } else if ( u_nModeDraw == nDrawMode_Blur ) {
        clrSample = vec3(0.0, 0.0, 0.0);
        
        for ( int i = -nSize ; i <= nSize ; i++ ) {
            for ( int j = -nSize ; j <= nSize ; j++ ) {
                vec2Delta.s = float(j) * u_vecSizePixel.s;
                vec2Delta.t = float(i) * u_vecSizePixel.t;
                
                clrSample += myCalcGaussianWeight(vec2Delta, 5.0) * 
                    texture2D(u_Sampler, vecTextureCoord + vec2Delta).rgb;
            }
        }
        
        vecMainClr = clrSample;
    } else if ( u_nModeDraw == 0 ) {
        vecMainClr += texture2D(u_Sampler4,  vecTextureCoord).rgb * 0.3015;
    }
    
    gl_FragColor = vec4(vecMainClr, 1.0);
}
</script>

<script language = "javascript">
var glhMain;

var frameBufferHead = null;
var frameBufferExceed = null;

var frameBufferD4  = null;
var frameBufferB4  = null;

var nDrawMode_ExtractExceed = 1;
var nDrawMode_ScaleDown     = 2;
var nDrawMode_Blur          = 3;

var nWidthCurr  = 0;
var nHeightCurr = 0;

var fFFar = 2048.0;

var pMatrix  = mat4.create();
var mvMatrix = mat4.create();

var bOnLight;

var vec3ColorAmb = [0.4, 0.4, 0.4];
var vec3ColorDir = [1.0, 1.0, 1.0];
var vec3DirLight = [-0.25, -0.25, -1.0];

var vecPosCamera = [0.0, 0.0, 0.0];

var arrObjs = [];
var arrStars = [];

var arrTexs = [];
var bufTexThermal;

var bufMeshStar;
var arrVtxStar;

var nNumStars = 16384;
var fSizeStarX = 0.002;
var fSizeStarY = 0.002;

var bIsDraging = false;

var nXDragPrev = 0, nYDragPrev = 0;

var fSensible = 0.003;
var fXAngleCamera = 0, fZAngleCamera = 0;

// Momentum is used instead of velocity because of its more convenient range
var gfMom;
var bIsOnDopplerEff = true;

var nTimeLast = 0;

var bufMeshBtns;
var fSizeBtn;

var nLoading = 0;


/*
  The following is the structure of JSON file : 
  (asterisked feature is able to be omitted)
    objs : array of objects --- {
      numVtx       : the number of vertices ( = vertices.length / 3 )
      numFace*     : the number of triangles consisting the mesh ( = inices.length / 3 )
      
      vertices     : containing the vertex positions
      normals      : containing the normal vectors of each vertex
      indices*     : containing the sequences of indices
      
      colors       : containing the colors of each vertex
                     if it contains only one color, it will be the uniform color
      texid*       : indicating the ID of texture
      texcoords*   : containing the texture coordinate of each vertex
      
      SameBefore*  : when it is not -1, this object is a duplicate of an object 
                     of which the index (in objs) is equal to this value
      
      scales       : scale of the mesh
      rotation     : information for rotation of the mesh
                     the length is the rotation angle, while the direction is the rotation axis
      position     : position of the mesh in the world
      
      texoffsetu*  : offset in the coordinate of texture
      texoffsetv*  
      texareau*    : actual area in the coordinate of texture
      texareav*    
      
      transparent* : indicating that this object is transparent
      radiation*   : this object is thermal radiating
                     one can give a fluctuation by texture and the temperature via 'color'
    }
    
    textures* : array of pathes of textures
    color_overall* : if you want to fill all objects with same color, give the color to this
*/


function myLoadWorldFromJSON(strDataJSON) {
    var i;
    
    var bufMesh;
    
    var pData;
    
    var nIdxOrg;
    var objPolyData;
    var arrBufColors;
    
    var nNumVtx, nNumFace;
    
    var matMVPoly, mat3Nor;
    var matOp;
    var fAngRot;
    
    // Clear previous objects
    for ( ; arrObjs.length > 0 ; ) {
        bufMesh = arrObjs.pop();
        
        delete bufMesh.matMVWorld;
        delete bufMesh.matMVWorldNormal;
        bufMesh.freeBuffer(glhMain);
        
        delete bufMesh;
    }
    
    for ( ; arrTexs.length > 0 ; ) {
        texBuf = arrTexs.pop();
        texBuf.freeBuffer(glhMain);
        delete texBuf;
    }
    
    // Parsing the JSON content
    pData = JSON.parse(strDataJSON);
    
    matOp = mat4.create();
    
    for ( i = 0 ; i < pData.objs.length ; i++ ) {
        bufMesh = new MeshBuffer();
        
        nIdxOrg = ( "SameBefore" in pData.objs[ i ] ? pData.objs[ i ].SameBefore : -1 );
        objPolyData = pData.objs[ ( nIdxOrg < 0 ? i : nIdxOrg ) ];
        
        //nNumVtx = pData.objs[ i ].numVtx;
        //nNumFace = pData.objs[ i ].numFaces;
        nNumVtx = objPolyData.numVtx;
        nNumFace = objPolyData.numFaces;
        
        bufMesh.insertVertexArray(glhMain, objPolyData.vertices, nNumVtx);
        bufMesh.insertNormalArray(glhMain, objPolyData.normals, nNumVtx);
        
        if ( nNumFace != 0 && "indices" in objPolyData ) {
            bufMesh.insertIndexArray(glhMain, objPolyData.indices, 3 * nNumFace);
        }
        
        arrBufColors = ( pData.objs[ i ].colors.length != 0 ? 
            pData.objs[ i ].colors : objPolyData.colors );
        
        if ( !( "color_overall" in pData ) ) {
            if ( arrBufColors.length == 4 * nNumVtx ) {
                bufMesh.insertColorArray(glhMain, arrBufColors, nNumVtx);
            } else {
                bufMesh.setUniformColor(glhMain, arrBufColors);
            }
        } else {
            bufMesh.setUniformColor(glhMain, pData.color_overall);
        }
        
        if ( "texid" in pData.objs[ i ] && "texcoords" in objPolyData ) {
            var dTexOffsetU, dTexOffsetV;
            var dTexAreaU, dTexAreaV;
            
            bufMesh.nIDTex = pData.objs[ i ].texid;
            bufMesh.insertTextureArray(glhMain, objPolyData.texcoords, nNumVtx);
            
            dTexOffsetU = ( "texoffsetu" in pData.objs[ i ] ? pData.objs[ i ].texoffsetu : 0.0 );
            dTexOffsetV = ( "texoffsetv" in pData.objs[ i ] ? pData.objs[ i ].texoffsetv : 0.0 );
            
            dTexAreaU = ( "texareau" in pData.objs[ i ] ? pData.objs[ i ].texareau: 1.0 );
            dTexAreaV = ( "texareav" in pData.objs[ i ] ? pData.objs[ i ].texareav: 1.0 );
            
            bufMesh.vec2TexOffset = [dTexOffsetU, dTexOffsetV];
            bufMesh.vec2TexArea   = [dTexAreaU,   dTexAreaV];
        } else {
            bufMesh.nIDTex = -1;
        }
        
        bufMesh.nIsRadiating = ( "radiation" in pData.objs[ i ] && pData.objs[ i ].radiation );
        
        // Preparing to calculate matrix
        matMVPoly = mat4.create();
        mat4.identity(matMVPoly);
        
        // Calculating the transformation matrix for world
        // In general, the transformation is done in the following sequence: 
        // Scaling -> Rotating -> Translating
        mat4.scale(matMVPoly, pData.objs[ i ].scales);
        
        // The length of this vector is the rotation angle while the direction is the axis
        // Also, no length, no rotation
        fAngRot = vec3.length(pData.objs[ i ].rotation);
        if ( fAngRot != 0 ) {
            vec3.scale(pData.objs[ i ].rotation, 1.0 / fAngRot, pData.objs[ i ].rotation);
            mat4.rotate(matMVPoly, fAngRot, pData.objs[ i ].rotation);
        }
        
        // The translate function in the gl library has a gap, 
        // So it should be manipulated by a hand like this
        matMVPoly[ 12 + 0 ] = pData.objs[ i ].position[ 0 ];
        matMVPoly[ 12 + 1 ] = pData.objs[ i ].position[ 1 ];
        matMVPoly[ 12 + 2 ] = pData.objs[ i ].position[ 2 ];
        
        bufMesh.matMVWorld = matMVPoly;
        
        // Calculating the transformation matrix for normal vectors
        mat3Nor = mat3.create();
        mat4.toInverseMat3(matMVPoly, mat3Nor);
        mat3.transpose(mat3Nor);
        
        bufMesh.matMVWorldNormal = mat3Nor;
        
        arrObjs.push(bufMesh);
    }
    
    if ( "textures" in pData ) {
        for ( i = 0 ; i < pData.textures.length ; i++ ) {
            arrTexs.push(new TextureBuffer(glhMain, pData.textures[ i ]));
        }
    }
    
    myCreateTextureThermalInfo();
    
    delete pData;
    
    return 0;
}


function myCreateStars() {
    var i;
    
    var fR, fTheta, fPhi;
    var fCosTheta, fSinTheta, fCosPhi, fSinPhi;
    var fX, fY, fZ;
    
    var arrVtx, arrIdx, arrTex;
    
    // Creating polygon for stars
    arrVtx = new Array();
    arrTex = new Array();
    arrIdx = new Array();
    
    fR = 0.1;
    
    for ( i = 0 ; i < nNumStars ; i++ ) {
        // Setting positions of stars randomly
        fTheta = Math.acos(2 * Math.random() - 1);
        fPhi   = 2.0 * Math.PI * Math.random();
        
        fCosTheta = Math.cos(fTheta);
        fSinTheta = Math.sin(fTheta);
        fCosPhi   = Math.cos(fPhi);
        fSinPhi   = Math.sin(fPhi);
        
        fX = fR * fSinTheta * fCosPhi;
        fY = fR * fSinTheta * fSinPhi;
        fZ = fR * fCosTheta;
        
        arrVtx.push(fX);
        arrVtx.push(fY);
        arrVtx.push(fZ);
        
        arrVtx.push(fX);
        arrVtx.push(fY);
        arrVtx.push(fZ);
        
        arrVtx.push(fX);
        arrVtx.push(fY);
        arrVtx.push(fZ);
        
        arrVtx.push(fX);
        arrVtx.push(fY);
        arrVtx.push(fZ);
        
        arrTex.push(-1.0);
        arrTex.push(-1.0);
        
        arrTex.push( 1.0);
        arrTex.push(-1.0);
        
        arrTex.push(-1.0);
        arrTex.push( 1.0);
        
        arrTex.push( 1.0);
        arrTex.push( 1.0);
        
        arrIdx.push(4 * i + 0);
        arrIdx.push(4 * i + 1);
        arrIdx.push(4 * i + 2);
        
        arrIdx.push(4 * i + 1);
        arrIdx.push(4 * i + 3);
        arrIdx.push(4 * i + 2);
    }
    
    // Create mesh for stars
    bufMeshStar = new MeshBuffer();
    
    bufMeshStar.insertVertexArray(glhMain, arrVtx, 4 * nNumStars);
    bufMeshStar.insertIndexArray(glhMain, arrIdx, 3 * 2 * nNumStars);
    bufMeshStar.insertTextureArray(glhMain, arrTex, 2 * nNumStars);
    
    bufMeshStar.disableTextureMode();
    
    return 0;
}


function myCreateTextureThermalInfo() {
    var requestJSON = new XMLHttpRequest();
    
    requestJSON.open("GET", "thermal_info.json");
    
    requestJSON.onreadystatechange = function() {
        if ( requestJSON.readyState == 4 ) {
            var i;
            
            var gl;
            
            var pData;
            var pPixelThermal;
            
            var texThermal;
            
            pData = JSON.parse(requestJSON.responseText);
            
            pPixelThermal = [];
            
            for ( i = 0 ; i < 4 ; i++ ) {
                pPixelThermal = pPixelThermal.concat(pData);
            }
            
            bufTexThermal = new TextureBuffer();
            bufTexThermal.createTextureFromData(glhMain, new Float32Array(pPixelThermal), 
                2048, 4, true);
            
            nLoading -= 1;
        }
    };
    
    nLoading += 1;
    requestJSON.send();
    
    return 0;
}


function myCreateBtnForMom() {
    var arrVtx, arrIdx;
    
    var fOffsetBtns, fZ;
    
    fOffset = 0.005;
    fSizeBtn = 0.12;
    fZ = -1.0;
    
    arrVtx = [
        -1.0 + fSizeBtn / 2.0 + fOffset, -1.0 + fOffset + fSizeBtn, fZ, 
        -1.0 + fSizeBtn       + fOffset, -1.0 + fOffset,            fZ, 
        -1.0                  + fOffset, -1.0 + fOffset,            fZ, 
         1.0 - fSizeBtn / 2.0 - fOffset, -1.0 + fOffset,            fZ, 
         1.0 - fSizeBtn       - fOffset, -1.0 + fOffset + fSizeBtn, fZ, 
         1.0                  - fOffset, -1.0 + fOffset + fSizeBtn, fZ
    ];
    
    arrIdx = [0, 1, 2, 3, 4, 5];
    
    bufMeshBtns = new MeshBuffer();
    
    bufMeshBtns.insertVertexArray(glhMain, arrVtx, 6);
    bufMeshBtns.insertIndexArray(glhMain, arrIdx, 6);
    bufMeshBtns.setUniformColor(glhMain, [10.0, 0.7, 0.6, 0.3]);
    
    return 0;
}


// Putting the information of observers into the shader program
function mySetConfTransformation(vecPosCenter, gfVel, gfGamma, bIsStar) {
    glhMain.setUniformVal3fv(0, "u_vecPosCenter", vecPosCenter);
    glhMain.setUniformVal1f(0,  "u_fVelVtx",      gfVel);
    glhMain.setUniformVal1f(0,  "u_fGammaVtx",    gfGamma);
    
    glhMain.setUniformVal1f(0, "u_fVelFrag",   gfVel);
    glhMain.setUniformVal1f(0, "u_fGammaFrag", gfGamma);
    
    glhMain.setUniformVal1i(0, "u_bIsStar",    bIsStar);
    glhMain.setUniformVal1f(0, "u_fSizeStarX", fSizeStarX);
    glhMain.setUniformVal1f(0, "u_fSizeStarY", fSizeStarY);
    
    return 0;
}


// Putting the matrices for arranging of a given mesh in the 'world'
function mySetMatrixWorld(matMVWorld, matNWorld) {
    glhMain.setUniformMtx4(0, "u_matMVWorld", false, matMVWorld);
    glhMain.setUniformMtx3(0, "u_matNWorld",  false, matNWorld);
    
    return 0;
}


// Drawing all stars; the actual works are done in the shader program
function myDrawStars(gfVel, gfGamma) {
    var i;
    
    glhMain.disableLight();
    
    mySetConfTransformation(vecPosCamera, gfVel, gfGamma, true);
    bufMeshStar.drawMesh(glhMain, pMatrix, mvMatrix);
    
    return 0;
}


// To draw the simple button some several codes are needed than we think
function myDrawButtons() {
    var mat3I, mat4I;
    
    mat3I = mat3.create();
    mat3.identity(mat3I);
    
    mat4I = mat4.create();
    mat4.identity(mat4I);
    
    mySetMatrixWorld(mat4I, mat3I);
    mySetConfTransformation([0.0, 0.0, 0.0], 0.0, 1.0, false);
    
    glhMain.disableLight();
    
    bufMeshBtns.drawMesh(glhMain, mat4I, mat4I);
    
    return 0;
}


function mySetCanvasSizeFromSelection() {
    var arrSize;
    
    arrSize = ( document.getElementById("inputselCanvassize").value ).split(" ");
    
    return [Number(arrSize[ 0 ]), Number(arrSize[ 1 ])];
}


function myUpdateFrameInfo() {
    var nWidth;
    var nHeight;
    
    var canvasMain = document.getElementById("canvasMain");
    
    // Is in fullscreen mode? 
    // (1st is for general browsers and 2nd for Firefox and 3rd for Chrome)
    if ( !document.fullscreenElement && 
        !document.mozFullScreenElement && 
        !document.webkitFullscreenElement )
    {
        // Getting selected resolution and using it
        var arrSize = mySetCanvasSizeFromSelection();
        
        nWidth  = arrSize[ 0 ];
        nHeight = arrSize[ 1 ];
    } else {
        // Giving the size of fullscreen
        nWidth  = window.innerWidth;
        nHeight = window.innerHeight;
    }
    
    // Adjusting size of canvas
    canvasMain.width  = nWidth;
    canvasMain.height = nHeight;
    
    // Also adjusting size of viewport
    glhMain.setViewportWidth(nWidth);
    glhMain.setViewportHeight(nHeight);
    
    // Size of star = 2 px * 2 px
    fSizeStarX = 2.0 / nWidth;
    fSizeStarY = 2.0 / nHeight;
    
    if ( nWidthCurr != nWidth || nHeightCurr != nHeight ) {
        if ( frameBufferHead ) {
            glhMain.deleteFramebuffer(frameBufferHead);
            glhMain.deleteFramebuffer(frameBufferExceed);
            
            glhMain.deleteFramebuffer(frameBufferD4);
            glhMain.deleteFramebuffer(frameBufferB4);
        }
        
        frameBufferHead = glhMain.createFramebuffer();
        frameBufferExceed = glhMain.createFramebuffer();
        
        frameBufferD4  = glhMain.createFramebuffer(true, 0.25);
        frameBufferB4  = glhMain.createFramebuffer(true, 0.25);
        
        nWidthCurr  = nWidth;
        nHeightCurr = nHeight;
    }
    
    return 0;
}


// Initializing the scene
function myInitScene(gfVel, gfGamma, frameBufferCurr) {
    glhMain.launchFramebuffer(frameBufferCurr);
    glhMain.initDraw();
    
    // Set the perspective matrix
    // The far plane is set so far to show stars which are far and far away
    mat4.perspective(45, glhMain.getViewportRatio(), 0.1, fFFar, pMatrix);
    
    return 0;
}


function myDrawScene(gfVel, gfGamma) {
    var i;
    
    var matNor;
    var vecDirLightTurned = [0.0, 0.0, 0.0, 0.0];
    
    // Set matrix for camera
    mat4.identity(mvMatrix);
    mat4.rotate(mvMatrix, fXAngleCamera, [1, 0, 0]);
    mat4.rotate(mvMatrix, fZAngleCamera, [0, 1, 0]);
    
    // Draw objects
    // At first, drawing stars; all special options should be off
    glhMain.setUniformVal1i(0, "u_bIsOnDopplerEff", false); // Doppler effect is not applied to stars
    glhMain.setUniformVal1i(0, "u_bIsThermalObj", false); // Thermal is too
    myDrawStars(gfVel, gfGamma);
    
    // Set the configuration for light
    if ( bOnLight ) {
        vecDirLightTurned[ 0 ] = vec3DirLight[ 0 ];
        vecDirLightTurned[ 1 ] = vec3DirLight[ 1 ];
        vecDirLightTurned[ 2 ] = vec3DirLight[ 2 ];
        vecDirLightTurned[ 3 ] = 0.0;
        
        // Turn the direction of light via the camera matrix
        mat4.multiplyVec4(mvMatrix, vecDirLightTurned, vecDirLightTurned);
        
        glhMain.setLightAmbient(vec3ColorAmb);
        glhMain.setLightDirectional(vec3ColorDir, vecDirLightTurned);
        glhMain.enableLight();
    } else {
        glhMain.disableLight();
    }
    
    // Make configuration for drawing objects
    mySetConfTransformation(vecPosCamera, gfVel, gfGamma, false);
    glhMain.setUniformVal1i(0, "u_bIsOnDopplerEff", bIsOnDopplerEff);
    
    // Draw objects
    for ( i = 0 ; i < arrObjs.length ; i++ ) {
        mySetMatrixWorld(arrObjs[ i ].matMVWorld, arrObjs[ i ].matMVWorldNormal);
        
        glhMain.setUniformVal1i(0, "u_bIsThermalObj", arrObjs[ i ].nIsRadiating);
        
        if ( arrObjs[ i ].nIsRadiating ) {
            bufTexThermal.bindTexture(glhMain, 1);
            glhMain.setUniformVal1i(0, "u_SamplerThermal", 1);
        }
        
        if ( arrObjs[ i ].nIDTex >= 0 ) {
            arrTexs[ arrObjs[ i ].nIDTex ].bindTexture(glhMain, 0); // The 0 should be modified
            
            glhMain.setUniformVal2fv(0, "u_vec2TexOffset", arrObjs[ i ].vec2TexOffset);
            glhMain.setUniformVal2fv(0, "u_vec2TexArea",   arrObjs[ i ].vec2TexArea);
        }
        
        arrObjs[ i ].drawMesh(glhMain, pMatrix, mvMatrix);
    }
    
    // Draw buttons
    myDrawButtons();
}


function mySetPixelSizeInPostDraw() {
    glhMain.setUniformVal2fv(1, "u_vecSizePixel", 
        [1.0 / glhMain.getViewportWidth(), 1.0 / glhMain.getViewportHeight()]);
    
    return 0;
}


function myDrawAtomOfPostEffect(frameBufferDst, frameBufferSrc, nMode) {
    glhMain.launchFramebuffer(frameBufferDst);
    glhMain.initDraw(true);
    glhMain.setUniformVal1i(1, "u_nModeDraw", nMode);
    mySetPixelSizeInPostDraw();
    glhMain.drawPost(frameBufferSrc);
    glhMain.releaseFramebuffer(frameBufferDst);
}


function myDrawPostEffect() {
    // Extracting exceeding lights
    myDrawAtomOfPostEffect(frameBufferExceed, frameBufferHead, nDrawMode_ExtractExceed);
    
    // Scale down
    myDrawAtomOfPostEffect(frameBufferD4,  frameBufferExceed, nDrawMode_ScaleDown);
    
    // Applying blur effect
    myDrawAtomOfPostEffect(frameBufferB4,  frameBufferD4,  nDrawMode_Blur);
    
    myDrawAtomOfPostEffect(frameBufferD4,  frameBufferB4,  nDrawMode_Blur);
    myDrawAtomOfPostEffect(frameBufferB4,  frameBufferD4,  nDrawMode_Blur);
    myDrawAtomOfPostEffect(frameBufferD4,  frameBufferB4,  nDrawMode_Blur);
    myDrawAtomOfPostEffect(frameBufferB4,  frameBufferD4,  nDrawMode_Blur);
    //myDrawAtomOfPostEffect(frameBufferD4,  frameBufferB4,  nDrawMode_Blur);
    //myDrawAtomOfPostEffect(frameBufferB4,  frameBufferD4,  nDrawMode_Blur);
    
    glhMain.bindTextureNull();
    glhMain.initDraw(true);
    
    glhMain.setUniformVal1i(1, "u_nModeDraw", 0);
    glhMain.setUniformVal1i(1, "u_Sampler4",  1);
    
    glhMain.drawPost(frameBufferHead, [frameBufferB4]);
    
    return 0;
}


function myMakeAnimation(gfVel) {
    var nTimeNow, nElapsed;
    
    var gfVel;
    
    // What time is it?
    nTimeNow = new Date().getTime();
    nElapsed = 0;
    
    // Calculating some variables with respect to the elapsed time
    if ( nTimeLast != 0) {
        nElapsed = nTimeNow - nTimeLast;
        
        // Note that in OpenGL the coordinate is fliped in z-axis
        vecPosCamera[ 2 ] -= gfVel * nElapsed / 1000.0;
    }
    
    nTimeLast = nTimeNow;
}


function myDoTick() {
    var gfVel, gfGamma;
    
    // Running frame up
    requestAnimationFrame(myDoTick, 1000 / 60);
    
    if ( nLoading > 0 ) {
        return 0;
    }
    
    // Getting all inputs
    gfMom = parseFloat(document.getElementById("inputtextMom").value);
    bIsOnDopplerEff = document.getElementById("inputchkboxDopplerEff").checked;
    
    // Calculating velocity (divided by c) and gamma from momentum ( / mass)
    gfVel = gfMom / Math.sqrt(1 + gfMom * gfMom);
    gfGamma = 1.0 / Math.sqrt(1 - gfVel * gfVel);
    
    // Updating configurations for frame
    myUpdateFrameInfo();
    
    // Okay, do it
    myInitScene(gfVel, gfGamma, frameBufferHead);
    myDrawScene(gfVel, gfGamma);
    glhMain.releaseFramebuffer(frameBufferHead);
    
    // Doing post effect
    myDrawPostEffect();
    
    myMakeAnimation(gfVel);
    
    // Dumping informations (momentum, velocity, gamma)
    document.getElementById("divOutVel").innerHTML =   "Velocity = " + gfVel + "&nbsp;&nbsp;";
    document.getElementById("divOutGamma").innerHTML = "Gamma = "    + gfGamma;
}


function myIsClickOnBtn(fX, fY, bIsTouch) {
    var fScale;
    
    fScale = ( bIsTouch ? 1.5 : 1.0 );
    
    if ( fY <= -1.0 + fSizeBtn * fScale ) {
        if ( fX <= -1.0 + fSizeBtn * fScale ) {
            return 1;
        } else if ( fX >= 1.0 - fSizeBtn * fScale ) {
            return -1;
        }
    }
    
    return 0;
}


function handleEventDragStart(nX, nY, nRelX, nRelY, bIsTouch) {
    var canvasMain = document.getElementById("canvasMain");
    
    var fX, fY;
    
    var nStateBtn;
    
    fX = nRelX * 2.0 / canvasMain.width - 1.0;
    fY = 1.0 - nRelY * 2.0 / canvasMain.height;
    
    nStateBtn = myIsClickOnBtn(fX, fY, bIsTouch);
    
    if ( nStateBtn == 0 ) {
        bIsDraging = true;
        nXDragPrev = nX;
        nYDragPrev = nY;
    } else {
        gfMom += 0.1 * nStateBtn;
        
        document.getElementById("inputtextMom").value = gfMom.toFixed(1);
    }
}


function handleEventDragEnd() {
    bIsDraging = false;
}


function handleEventDraging(nX, nY) {
    var nXDragCurr, nYDragCurr;
    
    if ( !bIsDraging ) {
        nXDragCurr = nYDragCurr = 0;
        
        return;
    }
    
    nXDragCurr = nX;
    nYDragCurr = nY;
    
    fXAngleCamera += ( nYDragCurr - nYDragPrev ) * fSensible;
    fZAngleCamera += ( nXDragCurr - nXDragPrev ) * fSensible;
    
    if ( fXAngleCamera < -Math.PI / 2 * 0.95 ) {
        fXAngleCamera = -Math.PI / 2 * 0.95;
    }
    
    if ( fXAngleCamera >  Math.PI / 2 * 0.95 ) {
        fXAngleCamera =  Math.PI / 2 * 0.95;
    }
    
    if ( fZAngleCamera < 0 ) {
        fZAngleCamera += 2 * Math.PI;
    }
    
    if ( fZAngleCamera > 2 * Math.PI ) {
        fZAngleCamera -= 2 * Math.PI;
    }
    
    nXDragPrev = nXDragCurr;
    nYDragPrev = nYDragCurr;
}


function myLoadJSON(strPath) {
    var requestJSON = new XMLHttpRequest();
    
    requestJSON.open("GET", strPath);
    
    requestJSON.onreadystatechange = function() {
        if ( requestJSON.readyState == 4 ) {
            myLoadWorldFromJSON(requestJSON.responseText);
            nLoading -= 1;
        }
    };
    
    nLoading += 1;
    requestJSON.send();
    
    return 0;
}


function mySetupGLHeaderForRelativity() {
    var strShaderVtxCode;
    var strShaderFragCode;
    var strShaderPostCode;
    
    var objNext;
    
    // Loading the vertex shader code
    strShaderVtxCode = "";
    objNext = document.getElementById("vscodeRelativity").firstChild;
    
    while ( objNext ) {
        if ( objNext.nodeType == 3 ) {
            strShaderVtxCode += objNext.textContent;
        }
        
        objNext = objNext.nextSibling;
    }
    
    glhMain.setShaderCodeVtx(strShaderVtxCode);
    
    // Loading the fragment shader code
    strShaderFragCode = "";
    objNext = document.getElementById("fscodeRelativity").firstChild;
    
    while ( objNext ) {
        if ( objNext.nodeType == 3 ) {
            strShaderFragCode += objNext.textContent;
        }
        
        objNext = objNext.nextSibling;
    }
    
    glhMain.setShaderCodeFrag(strShaderFragCode);
    
    // Loading the fragment shader code
    strShaderPostCode = "";
    objNext = document.getElementById("fscodePostEff").firstChild;
    
    while ( objNext ) {
        if ( objNext.nodeType == 3 ) {
            strShaderPostCode += objNext.textContent;
        }
        
        objNext = objNext.nextSibling;
    }
    
    glhMain.setShaderCodePost(strShaderPostCode);
    
    return 0;
}


function myLaunchGL() {
    var canvasMain = document.getElementById("canvasMain");
    
    // Size of star = 2 px * 2 px
    fSizeStarX = 2.0 / canvasMain.width;
    fSizeStarY = 2.0 / canvasMain.height;
    
    glhMain = new glHeader();
    
    mySetupGLHeaderForRelativity();
    
    glhMain.initGL(canvasMain);
    
    bOnLight = true;
    
    canvasMain.innerHTML = "Loading...";
    
    myLoadJSON(document.getElementById("inputselWorld").value);
    myCreateStars();
    myCreateBtnForMom();
    
    glhMain.setUsingFramebuffer(true);
    
    // Adding event listeners
    // The first three are for mouse-draging and the followings are for touch
    
    canvasMain.addEventListener("mousedown", function(event) {
        return handleEventDragStart(event.clientX, event.clientY, 
            event.pageX - this.offsetLeft, event.pageY - this.offsetTop, false);
    }, false);
    
    document.addEventListener("mouseup", function(event) {
        return handleEventDragEnd();
    }, false);
    
    document.addEventListener("mousemove", function(event) {
        return handleEventDraging(event.clientX, event.clientY);
    }, false);
    
    canvasMain.addEventListener("touchstart", function(event) {
        var objTouch;
        
        if ( event.changedTouches.length != 1 ) {
            return 0;
        }
        
        var objTouch = event.changedTouches[ 0 ];
        
        return handleEventDragStart(-objTouch.clientX, -objTouch.clientY, 
            objTouch.pageX - this.offsetLeft, objTouch.pageY - this.offsetTop, true);
    }, false);
    
    document.addEventListener("touchend", function(event) {
        return handleEventDragEnd();
    }, false);
    
    document.addEventListener("touchmove", function(event) {
        var objTouch;
        
        if ( event.changedTouches.length != 1 ) {
            return 0;
        }
        
        objTouch = event.changedTouches[ 0 ];
        
        return handleEventDraging(-objTouch.clientX, -objTouch.clientY);
    }, false);
    
    myDoTick();
}


function mySetFullscreen() {
    canvasMain = document.getElementById("canvasMain");
    
    if ( canvasMain.requestFullscreen ) {
        canvasMain.requestFullscreen();
    } else if ( canvasMain.mozRequestFullScreen ) {
        canvasMain.mozRequestFullScreen();
    } else if ( canvasMain.webkitRequestFullscreen ) {
        canvasMain.webkitRequestFullscreen();
    }
    
    return 0;
}


function myResetAll() {
    document.getElementById("inputtextMom").value = 0.0;
    
    vecPosCamera[ 0 ] = 0.0;
    vecPosCamera[ 1 ] = 0.0;
    vecPosCamera[ 2 ] = 0.0;
    
    fXAngleCamera = 0.0;
    fZAngleCamera = 0.0;
}
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
              tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
                });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</head>

<body onload = "myLaunchGL();">



<h1>Demonstration</h1>

<canvas id = "canvasMain" style = "border:none; " width = 1024 height = 768>
This browser does not suppot HTML5. Upgrade it.
</canvas>
<br>
<div>
Momentum / m<sub>observer</sub>c = 
<input type = "number" id = "inputtextMom" step = "0.1" value = "0.0">&nbsp;&nbsp;
size : <select id = "inputselCanvassize">
  <option value = "800 600">800 x 600</option>
  <option value = "1024 768" selected>1024 x 768</option>
  <option value = "1280 960">1280 x 960</option>
  <option value = "1280 1024">1280 x 1024</option>
  <option value = "1600 1200">1600 x 1200</option>
</select>&nbsp;&nbsp;
world : <select id = "inputselWorld" onchange = 'myLoadJSON(this.value);'>
  <option value = "worldmodel_boxes_colored.json">boxes - RGB</option>
  <option value = "worldmodel_boxes_allred.json">boxes - only red</option>
  <option value = "worldmodel_boxes_allgreen.json">boxes - only green</option>
  <option value = "worldmodel_boxes_allblue.json">boxes - only blue</option>
  <option value = "worldmodel_spheres.json">spheres</option>
  <option value = "worldmodel_utah_teapots.json">Utah teapots</option>
  <option value = "worldmodel_stars.json">Stars</option>
  <option value = "worldmodel_buildings.json">Town</option>
</select>&nbsp;&nbsp;
<label><input type = "checkbox" id = "inputchkboxDopplerEff" value = "1">Doppler effect</label>&nbsp;&nbsp;
<input type = "button" value = "Fullscreen" onclick = 'mySetFullscreen();'>&nbsp;
<input type = "button" value = "Reset" onclick = "myResetAll();">
</div>
<table border = 0 cellpadding = 0 cellspacing = 0>
<tr>
<td width = 320 style = "white-space: nowrap;"><div id = "divOutVel"></div></td>
<td><div id = "divOutGamma"></div></td>
</tr>
</table>
<div id = "divDump2"></div>
</body>
</html>


